# 最短路问题

## 单源最短路

### （1）多有边权都是正数（Dijkstra算法）

* （稠密图） 朴素Dijkstra算法  O（n^2）

**算法步骤：**
1. dist[1] = 0, dist[i] = INF
2. for i : [1, n]:
    t <- 不在s中的距离最近的点
    s <- t
    用t更新其它点的距离 （从t出去的所有的边，组成的路径，能不能更新其他点的距离）  if（dist[x] > dist[t] + w） 更新距离
 
* （稀疏图）堆优化版Dijkstra算法

**算法步骤：**
1. dist[1] = 0, dist[i] = INF
2. for i : [1, n]:
    t <- 不在s中的距离最近的点（用堆优化处理）
    s <- t
    用t更新其它点的距离 （从t出去的所有的边，组成的路径，能不能更新其他点的距离）  if（dist[x] > dist[t] + w） 更新距离

### （2）存在负边权

#### Bellman-Ford

**算法步骤：**
for n 次       （若是k次， 意义是：从1号点，走的步数不超过k次**即不超过k条边**，到每个点的最短距离）
    for 遍历所有边 a，b，w  （要备份）  a->b
        dist[b] = min(dist[b], dist[a] + w)     -> 松弛操作

1. 循环n次之后，一定满足 dist[b] <= dist[a] + w (三角不等式)
2. 若第n+1次循环还有更新，则说明存在负环
3. 更新距离数组的时候一定要备份，不要有可能会发生串联的连锁更新
4. Bellman-Ford可以用来找负环，但复杂度高，找负环的话，用SPFA算法

#### SPFA

**算法步骤：**
1. queue <- 1
2. while queue不空
   1. t <- q.front  q.pop
   2. 更新t的所有出边  t -> b (w边权)    queue <- b 

1. 只有前面的点更新变小了，其后继的点才有可能更新

**SPFA判负环：**
1. dist[x] : 1->x 的最短距离
2. cnt[x] : 当前最短路的边数（有多少条边）
3. 更新 dist[x] = dist[t] + w[i]; cnt[x] = cnt[t] + 1; 若存在cnt[x] >= n，由抽屉原理，一定存在环，而且环变小了，所以存在负环

## 多源最短路

**算法步骤：**  用邻接矩阵d[i][j] 表示 i 到 j 的最短距离
for (k = 1; k <= n; k++)
    for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++)
        d[i][j] = min(d[i][j], d[i][k] + d[k][j])